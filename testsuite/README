--------------
-- Contents --
--------------

This is a python driven testsuite for GNATcoverage.

Most tests use gprbuild to build programs for run/analysis by gnatcov/gnatemu.

The testsuite driver is <topdir>/testsuite.py.
It scans the subdirectories for "test.py" instances and runs every one
it finds after switching to where it was found.

Down the "Qualif" subdirectory reside our current set of do178
"qualification" tests. See the "content.txt" file there for more info
on the organization of this part.

-------------------
-- Prerequisites --
-------------------

You need, on your PATH:

 * The gnatcov & <target>-gnatemu binaries you wish to exercise

 * A target compiler supporting -fpreserve-control-flow and coming with
   runtimes allowing execution in <target>-gnatemu

 * gprbuild >= 1.3.0

 * gnatpython and rlimit. If you don't have a binary package at hand, you
   may install the necessary subset with:

     git clone https://forge.open-do.org/anonscm/git/gnatpython/gnatpython.git

   Add the extracted directory to your PYTHONPATH, then compile rlimit and
   add it to your PATH. Or run ./setup.py install to install the gnatpython
   package in your python distribution.

If you are running tests for a zfp or ravenscar configuration (not a full
runtime), you also need at the toplevel, together with this README:

 * A "support" subdirectory corresponding to the one in the gnatcov examples.

   If you retrieved this testsuite subdir as part of a full GNATcoverage tree,
   you have the gnatcov sources in ../tools and may for example do:

     ln -s ../tools/gnatcov/examples/support support

-----------------------
-- Running the tests --
-----------------------

For a powerpc-elf target, run:
  ./testsuite.py --diffs --target=ppc-elf --RTS=powerpc-elf/zfp-prep

For a native x86-linux configuration, if you have a properly instrumented
version of valgrind, remove --target and pass --RTS=native:

  ./testsuite.py --diffs --RTS=native

To run a specific set of tests, append a regexp of test directory names to
this command line.

After test runs, each test directory contains:

  test.py.log, a list of all the commands executed by the test.
  test.py.out, all the produced outputs.
  test.py.err, all the produced outputs.

The toplevel directory contains res_couverture and rep_couverture
synthesis files in addition.

-----------------------------------------
-- General python support architecture --
-----------------------------------------

The toplevel driver is testsuite.py. It spawns independant instances of
test.py:
                    
  testsuite.py ---o-spawn-> subdir1/test.py
                  |
		  o-spawn-> subdir2/test.py

We provide a few modules of facilities to help test writers and allow
sharing pickled data between tests and the toplevel driver, required for
the production of qualification "test-results" reports. Below is a rough
sketch of the overall architecture:

Modules are split in two packages:

  SUITE - set of modules relevant across the entire set of tests
  SCOV  - set of modules relevant for source coverage tests in particular

The split in modules is designed to isolate ~standalone functional facilities
and cut harmful dependencies.

Each test relies on a single Test object, which holds and controls the test
execution context (switch to initial test directory, parse command line
options, maintain execution status, ...). This facility is offered by the
SUITE.context module, which instanciates the object, and needs to be imported
only in a test.py context. Any dependency on the "current test context" module
from the toplevel driver makes no sense at all and would most probably cause
a testsuite failure.

This settled, we have:

 SUITE
 -----
   cutils.py  : Common utilities, for both tests and the toplevel driver
                [e.g. to_list(blob), contents_of(filename), ...]

   context.py : Current test context [Test class, "thistest" instance]

   tutils.py  : Common utilities that depend on "thistest" instance, so
                for tests only [xrun, gprbuild, ???]

   qdata.py   : Qualification reports facilities, to allow queuing
                pickled data between tests and the toplevel driver

 SCOV
 ----
   tc.py      : TestCase class for source coverage tests

   report.py  : Format checker for qualified reports, 

   map.py     : MapChecker class for gnatcov map-routines tests

   internals
   ---------
     cnotes.py    : Classes to represent expected or emitted coverage notes

     driver.py    : Class to help drive a source coverage test [SCOV_helper]

     expanders.py : Expand coverage note instances from gnatcov reports or from
                    expectation-specs + sources

     xnotep.py    : Class to represent user expectation patterns

     segments.py :  Source segment abstractions [line, line:col, ...], to
                    help check for inclusions.

     tfiles.py :    Text files (and lines) abstractions to automate processing
                    on read and assign numbers to lines.
                     
