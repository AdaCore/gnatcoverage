
DC assessements are all governed by a toplevel base requirement which settles
the notion of *decision*:

===============   =============================================================
Requirement Id    Description
===============   =============================================================
**base**          The tool shall recognize as decisions any *simple* or
                  *complex* Boolean expression that directly controls the
                  behavior of IF, WHILE and EXIT-WHEN control-flow
                  constructs.  Only the expression as a whole is considered a
                  decision; subexpressions are not decisions on their own.

                  *Simple* expressions are Boolean atoms such as a lone
                  Boolean variable or a function call result, possibly
                  negated. *Complex* expressions are those that feature at
                  least two Boolean atoms combined with AND-THEN or OR-ELSE
                  short-circuit operators. The Boolean atoms in a decision are
                  called *conditions*.

                  The types involved need not be restricted to the standard
 		  Boolean type; they may subtypes or types derived from the
 		  Ada fundamental type.
===============   =============================================================


In this context, the following set of subsidiary requirements shall all be
obeyed:

===============   =============================================================
Requirement Id    Description
===============   =============================================================
**snoexec**       When the control-flow statement influenced by a decision
                  has not been executed, that statement shall be reported as
                  not covered and nothing shall be reported about the decision.

**dnoeval**       When a decision is never evaluated even though the enclosing
                  statement has been executed (e.g. because of exceptions
                  preventing the computation of an outcome), the decision
		  shall be reported as never evaluated.

**dparteval**     When a decision is evaluated only True or False, it shall be
                  reported as only partially covered. In this case as in the
                  previous one, the tool shall designate the decision with an
                  unambiguous file-name:line#:col# reference.

**dcovered**      When a decision is evaluated both True and False, no decision
                  coverage violation shall be reported for it.

**dcomplete**     The tool shall be able to handle arbitrarily complex
                  decisions in any context where they might appear.
===============   =============================================================


**Testing Strategy**

To address *dcomplete*, we check that all the aspects of this requirement are
satisfied in a wide variety of situations. We start with two subsets of
testcases:

* ``Topologies`` exercise a panel of expression topologies over Boolean
  variables (single value, negated, two or more combined with and-then or
  or-else, ...), each placed in a variety of program contexts,

* ``Operands`` exercise basic expressions (no more than two operands) over
  different kinds of operands (attribute references, subprogram calls, ...;
  not only simple boolean variables), each placed in a variety of program
  contexts as well.

We exercise each decision of interest in multiple manners, always including

* a set of vectors where the decision evaluates only True (*dparteval*),

* a set of vectors where the decision evaluates only False (*dparteval*),

* a set of vectors where the decision evaluates both True and False
  (*dcovered*),

* a situation where the statements exposing the decision aren't
  executed at all (*snoexec*).

On top of this, the ``NoEval`` subset of tests addresses the particular
*dnoeval* case, a rare kind of occurrence in practice.
