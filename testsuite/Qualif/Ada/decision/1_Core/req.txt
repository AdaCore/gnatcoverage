
===============   ===========================================================
Requirement Id    Description
===============   ===========================================================
**core**          The tool shall recognize as decisions any *simple* or
                  *complex* Boolean expressions that directly influence the
                  behavior of IF, WHILE, FOR, and EXIT-WHEN explicit
                  control-flow constructs. Only the expression as a whole is
                  considered a decision; subexpressions are not decisions on
                  their own.
===============   ===========================================================

*Simple* expressions are Boolean atoms such as a lone Boolean variable or a
function call result, possibly negated. *Complex* expressions are those that
feature at least two Boolean atoms combined with AND-THEN or OR-ELSE
short-circuit operators. The Boolean atoms in a decision are called
*conditions*.

The types involved need not be the standard language Boolean type; they may
subtypes or types derived from the Ada fundamental type. Subexpressions are
not considered as separate

In this context, the following set of subsidiary requirements shall be
obeyed:

===============   ===========================================================
Requirement Id    Description
===============   ===========================================================
**snoexec**       When the control-flow statement influenced by a decision
                  has not been executed, that statement shall be reported as
                  not covered and nothing shall be reported about the decision.
**dnoeval**       When a decision is never evaluated even though the enclosing
                  statement has been executed (e.g. because of exceptions
                  preventing the computation of an outcome), the decision
		  shall be reported as never evaluated.
**dparteval**     When a decision is evaluated only True or False, it shall be
                  reported as only partially covered. In this case as in the
                  previous one, the tool shall designate the decision with an
                  unambiguous file-name:line#:col# reference.
**dcovered**      When a decision is evaluated both True and False, no decision
                  coverage violation shall be reported for it.
**dcomplete**     The tool shall be able to handle arbitrarily complex
                  decisions in any context where they might appear.
===============   ===========================================================


**Testing Strategy**

To address *dcomplete*, we check that all the aspects of this requirement are
satisfied in a variety of situations. We start with two subsets of testcases:

* [Operands] basic expressions involving different kinds of operands, not only
  simple boolean variables (e.g. attribute references or subprogram calls).

* [Contexts] expressions of various topologies placed in various contexts, to
  verify the tool's capability to handle arbitrary expressions everywhere
  they might appear.

We exercise each decision of interest in multiple manners, always including

* a set of vectors where the decision evaluates only True (*dparteval*),

* a set of vectors where the decision evaluates only False (*dparteval*),

* a set of vectors where the decision evaluates both True and False
  (*dcovered*),

* a situation where the statements exposing the decision aren't
  executed at all (*snoexec*).

On top of this, we add a [NoEval] subset of tests to address the particular
*dnoeval* case, a rare kind of occurrence in practice.
