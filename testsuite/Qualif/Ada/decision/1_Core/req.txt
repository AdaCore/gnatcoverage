The tool shall recognize as decisions any expression that directly influences
the behavior of language explicit control constructs: if, while, for, and
exit-when. The types involved shall not necessarily be the standard language
Boolean type. It could be a subtype or a type derived from that Ada
fundamental type.

In this context:

#. When a decision is enclosed in a statement or declaration that has not been
   executed, that statement or declaration shall be reported as not covered
   and nothing shall be reported about the decision.

#. When a decision is never evaluated even though the enclosing statement or
   declaration has been executed, the decision shall be reported as never
   evaluated.

#. When a decision is evaluated only True or False, it shall be reported as
   only partially covered. In this case as in the previous one, the tool shall
   designate the decision with an unambiguous file-name:line#:col# reference.

#. When a decision is evaluated both True and False, no decision coverage
   violation shall be reported for it.

#. The tool shall be able to handle arbitrarily complex decisions in any
   context where such expressions might appear.

**Testing Strategy**

We check that all the aspects of this requirement are satisfied
in a variety of situations, split into two major subsets:

* Operands: expressions involving different kinds of operands, not only simple
  boolean variables (e.g. attribute references, subprogram calls, ...).

* Contexts: expressions of different kinds placed in various contexts, to
  verify the tool's capability to handle arbitrary expressions everywhere
  they might appear.

We exercise each decision of interest in multiple manners, always including

* a set of vectors where the decision evaluates only True,

* a set of vectors where the decision evaluates only False,

* a set of vectors where the decision evaluates both True and False,

* a situation where the statements exposing the decision aren't
  executed at all.

