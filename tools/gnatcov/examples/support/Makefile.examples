# This support Makefile is a helper for examples packaged together with
# GNATcoverage.  The intent is to have this Makefile invoked from the example
# dedicated directories.

# It is useful both to factorize the work for different examples and to
# illustrate a typical coverage data generation sequence for a program
# starting from sources.

# Each individual example is expected to provide
#
# - Some source code subject to coverage analysis, exercised by one or several
#   test drivers (main subprograms) calling into the code.  Test drivers
#   should be named test_<something> and the set of drivers of relevance for
#   a given exmple should be listed in the TESTS Makefile variable.
#
# - A general project file named after the example subdirectory (foo.gpr for
#   an example located in subdirectory foo), used to build, without a Main
#   attribute (providing a Source_Dirs at least, Object_Dir possibly, ...)

# The basic idea is, first for each test driver, to:
#
#  1/ Build the program binary executable from the sources
#  2/ Run it through "gnatcov run" to get an execution trace
#  3/ Use "gnatcov coverage" to produce a report out of the trace
#
# Then, optionally, as determined by the CONSOLIDATE variable value
# for the example as a whole:
#
#  4/ Use gnatcov coverage to produce a consolidated report, from all the test
#     traces or from checkpoints.

# Set of main target programs for which we want to produce coverage info,
# to be defined from the command line or by includers:
# TESTS=

# To produce a consolidated report combining the effects of all the test
# drivers, set to 'traces' or 'checkpoints' from includers or command line:
# CONSOLIDATE=

# User arguments to pass to the builder
BUILDFLAGS=

# Kind of coverage analysis to be performed (--level argument)
XCOVLEVEL?=stmt+decision

include ../support/Makefile.common

# ----------------------------------------------------------------------------
# Object vs source coverage action variants for common rules
# ----------------------------------------------------------------------------

# In e.g. the Aunit case, we're only interested in results for our applicative
# objects so query for the specific list of relevant symbols, which implicitly
# excludes (hence doesn't list) results for the test-harness code.

# Beware that these actions may be involved in different rules, so some
# automatic variables like $< don't expand the same across actions.

OBJECT_LEVELS=branch insn
SOURCE_LEVELS=stmt stmt+decision stmt+mcdc

BINDIR = obj/$(TARGET)
BASEDIR = $(notdir $(CURDIR))

ifneq ($(filter $(OBJECT_LEVELS), $(XCOVLEVEL)),)

  # Object coverage: use --routines to filter. Compile with -g to
  # allow annotated-source report formats.

  INTERNALBUILDFLAGS = -g
  GENXCOVLIST=\
    $(XCOV) disp-routines $(wildcard $(BINDIR)/*.o) | grep -v test_ > $*-routines.list
  XCOVFILTER=--routines=@$*-routines.list
  XCOVRUN=$(XCOV) run \
    $(XCOVTARGET) --level=$(XCOVLEVEL) $(BINDIR)/$* -o $*.trace

else
ifneq ($(filter $(SOURCE_LEVELS), $(XCOVLEVEL)),)

  # Source coverage: force -g -fdump-scos -fpreserve-control-flow, use --scos
  # to filter and pass the filter to xcov run so that it has visibility on
  # decision locations

  INTERNALBUILDFLAGS = -cargs -g -fdump-scos -fpreserve-control-flow
  GENXCOVLIST=\
    ls $(wildcard $(BINDIR)/*.ali) | grep -v test_ > $*-alis.list
  XCOVFILTER=--scos=@$*-alis.list
  XCOVRUN=$(XCOV) run \
    $(XCOVTARGET) --level=$(XCOVLEVEL) $(XCOVFILTER) $(BINDIR)/$* -o $*.trace
endif
endif

# Argument we will pass to the builder eventually
BUILDERFLAGS=$(INTERNALBUILDFLAGS) $(BUILDFLAGS)

ALL_TESTS=$(TESTS) $(UNIT_TESTS)

.PRECIOUS: %.trace

all: build trace analyze consolidate-$(CONSOLIDATE)

announce-%: force
	@echo "--------------" $* "--------------"

# -------------------------------------------------------------------------
# consolidation targets
# -------------------------------------------------------------------------

ALL_CHECKPOINTS=$(ALL_TESTS:%=%.ckpt)
ALL_TRACES=$(ALL_TESTS:%=%.trace)

consolidate-:

consolidate-checkpoints: announce-consolidate-checkpoints
consolidate-checkpoints: out-all-checkpoints/index.html

ckpt.list: force
	$(RM) -f $@ && touch $@
	for ckpt in $(ALL_CHECKPOINTS); do echo $$ckpt >> $@; done

out-all-checkpoints/index.html: out-all-checkpoints $(ALL_CHECKPOINTS) ckpt.list
	$(XCOV) coverage --level=$(XCOVLEVEL) \
	 --checkpoint=@ckpt.list \
	 --annotate=dhtml --output-dir=$(dir $@)

%.ckpt: %.trace
	$(XCOV) coverage $(XCOVFILTER) --level=$(XCOVLEVEL) \
	 --save-checkpoint=$@ $*.trace

consolidate-traces: announce-consolidate-traces
consolidate-traces: out-all-traces/index.html

out-all-traces/index.html: out-all-traces $(ALL_TRACES)
	$(XCOV) coverage $(XCOVFILTER) --level=$(XCOVLEVEL) \
	 --annotate=dhtml $(ALL_TRACES) \
	 --output-dir $(dir $@)

# -----------------------------------------------------------------------
# analyze: produce annotated sources or html from a trace file and
#          the corresponding executable
# -----------------------------------------------------------------------

analyze: announce-analyze
analyze: $(ALL_TESTS:%=out-%/index.html)

out-%: force
	$(RM) -rf $@
	$(MKDIR) $@

out-%/index.html: out-% %.trace
	$(XCOV) coverage $(XCOVFILTER) \
	 --level=$(XCOVLEVEL) --annotate=dhtml $*.trace --output-dir $(dir $@)

out-%/index.xml: out-% %.trace
	$(XCOV) coverage $(XCOVFILTER) \
	 --level=$(XCOVLEVEL) --annotate=xml $*.trace --output-dir $(dir $@)

out-%/report.txt: out-% %.trace
	$(XCOV) coverage $(XCOVFILTER) \
	 --level=$(XCOVLEVEL) --annotate=report $*.trace -o $@

# -----------------------------------------------------------------------
# trace: produce execution trace from executable program execution
#        within instrumented target emulation environment
# -----------------------------------------------------------------------

trace: announce-trace
trace: $(ALL_TESTS:%=%.trace)

%.trace: % force
# Generate the filtering list here, as we might need to pass it to
# gnatcov run and always need to pass it to gnatcov coverage.

	$(GENXCOVLIST)

# Then echo the command we're planning to run while our term is functional,
# and run silently in between the possibly required stty adjustments. Make
# sure the latter executes in sequence entirely so that tty gets restored
# even if XCOVRUN fails for whatever reason.

	@echo $(XCOVRUN)
	@$(STTY_ADJUST) $(XCOVRUN); $(STTY_RESTORE) echo

# -----------------------------------------------------------------------
# build: produce executable program from sources + target bsp
# -----------------------------------------------------------------------

build: $(ALL_TESTS)

$(ALL_TESTS): announce-build-tests

$(TESTS): libsupport force
	$(BUILDER) -q -f -p $@.adb -P$(BASEDIR).gpr $(BUILDERFLAGS)

$(UNIT_TESTS): libsupport force
	$(BUILDER) -q -f -p -Pharness $(BUILDERFLAGS)\
	-XRUNTIME=zfp -XUNITTEST=yes -XPLATFORM=$(TARGET)

MKSUPPORT=$(MAKE) -C $(SUPPORT_DIR) -f Makefile.libsupport

libsupport: announce-build-libsupport
	$(MKSUPPORT) all

# -----------------------------------------------------------------------
# Housekeeping
# -----------------------------------------------------------------------

clean:
	$(MKSUPPORT) clean
	$(RM) -rf obj lib out-*
	$(RM) -f *.bin *.dmap *.cgpr *.trace.* *.trace *~ \
                 *.xcov *.html *.css *.xml $(TESTS) *.list

.PHONY: force clean
