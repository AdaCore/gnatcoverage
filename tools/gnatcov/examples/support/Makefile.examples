# This support Makefile is a helper for examples packaged together with
# GNATcoverage.  The intent is to have this Makefile invoked from the example
# dedicated directories.

# It is useful both to factorize the work for different examples and to
# illustrate a typical coverage data generation sequence for a program
# starting from sources.

# The basic idea is
#  1/ Build the program binary executable from the sources
#  2/ Run it through qemu to get execution traces
#  3/ Use gnatcov to produce user level coverage data from the traces

# Set of main target programs for which we want to produce coverage info,
# to be defined from the command line or by includers:
# TESTS=
#
# ??? More than one entry in this list is not completely supported yet.
# Everything is done to have the correct sequence of operations for
# each, but final results for one are likely to be intermixed or partially
# clobbered by those for another.

# User arguments to pass to the builder
BUILDFLAGS=

# Kind of coverage analysis to be performed (--level argument)
XCOVLEVEL?=stmt+decision

# ---------------------------------------------------------------------------
# Pick a default RTS from TARGET, if not provided already
# ---------------------------------------------------------------------------

RTS = 
ifeq ($(TARGET), powerpc-elf)
RTS = ravenscar-sfp-prep
endif
ifeq ($(TARGET), powerpc-eabispe)
RTS = ravenscar-sfp-p2020
endif
ifeq ($(TARGET), leon-elf)
RTS = ravenscar
endif

include ../support/Makefile.common

# ----------------------------------------------------------------------------
# Object vs source coverage action variants for common rules
# ----------------------------------------------------------------------------

# In e.g. the Aunit case, we're only interested in results for our applicative
# objects so query for the specific list of relevant symbols, which implicitly
# excludes (hence doesn't list) results for the test-harness code.

# Beware that these actions may be involved in different rules, so some
# automatic variables like $< don't expand the same across actions.

OBJECT_LEVELS=branch insn
SOURCE_LEVELS=stmt stmt+decision stmt+mcdc

BINDIR = obj/$(TARGET)

ifneq ($(filter $(OBJECT_LEVELS), $(XCOVLEVEL)),)

  # Object coverage: use --routines to filter. No extra build option.

  INTERNALBUILDFLAGS =
  GENXCOVLIST=\
    $(XCOV) disp-routines $(wildcard $(BINDIR)/*.o) > $*.routines
  XCOVFILTER=--routines=@$*.routines
  XCOVRUN=$(XCOV) run \
    $(XCOVTARGET) --level=$(XCOVLEVEL) $(BINDIR)/$<

else
ifneq ($(filter $(SOURCE_LEVELS), $(XCOVLEVEL)),)

  # Source coverage: force -g -fdump-scos -fpreserve-control-flow, use --scos
  # to filter and pass the filter to xcov run so that it has visibility on
  # decision locations

  INTERNALBUILDFLAGS = -cargs -g -fdump-scos -fpreserve-control-flow
  GENXCOVLIST=\
    ls $(wildcard $(BINDIR)/*.ali) > $*.alis
  XCOVFILTER=--scos=@$*.alis
  XCOVRUN=$(XCOV) run \
    $(XCOVTARGET) --level=$(XCOVLEVEL) $(XCOVFILTER) $(BINDIR)/$<
endif
endif

# Argument we will pass to the builder eventually
BUILDERFLAGS=$(INTERNALBUILDFLAGS) $(BUILDFLAGS)

.PRECIOUS: %.trace

all: build trace analyze

# -----------------------------------------------------------------------
# analyze: produce annotated sources or html from a trace file and
#          the corresponding executable
# -----------------------------------------------------------------------

analyze: $(TESTS:%=index-%.html) $(UNIT_TESTS:%=index-%.html)

index-%.html: %.trace
	$(XCOV) coverage $(XCOVFILTER) \
	 --level=$(XCOVLEVEL) --annotate=html+ $< 
	cp index.html $@

index-%.xml: %.trace
	$(XCOV) coverage $(XCOVFILTER) \
	 --level=$(XCOVLEVEL) --annotate=xml $< 
	cp index.xml $@

report-%.txt: %.trace
	$(XCOV) coverage $(XCOVFILTER) \
	 --level=$(XCOVLEVEL) --annotate=report $< \
	 -o $@

# -----------------------------------------------------------------------
# trace: produce execution trace from executable program execution
#        within instrumented target emulation environment
# -----------------------------------------------------------------------

trace: $(TESTS:%=%.trace) $(UNIT_TESTS:%=%.trace)

%.trace: % force
# Generate the filtering list here, as we might need to pass it to
# gnatcov run and always need to pass it to gnatcov coverage.

	$(GENXCOVLIST)

# Then echo the command we're planning to run while our term is functional,
# and run silently in between the possibly required stty adjustments. Make
# sure the latter executes in sequence entirely so that tty gets restored
# even if XCOVRUN fails for whatever reason.

	@echo $(XCOVRUN)
	@$(STTY_ADJUST) $(XCOVRUN); $(STTY_RESTORE) echo

# -----------------------------------------------------------------------
# build: produce executable program from sources + target bsp
# -----------------------------------------------------------------------

build: $(TESTS) $(UNIT_TESTS)

$(TESTS): libsupport force
	$(BUILDER) -f -p -P$@ $(BUILDERFLAGS)

$(UNIT_TESTS): libsupport force
	$(BUILDER) -f -p -Pharness $(BUILDERFLAGS)\
	-XRUNTIME=zfp -XUNITTEST=yes -XPLATFORM=$(TARGET)

MKSUPPORT=$(MAKE) -C $(SUPPORT_DIR) -f Makefile.libsupport

libsupport:
	$(MKSUPPORT) all

# -----------------------------------------------------------------------
# Housekeeping
# -----------------------------------------------------------------------

clean:
	$(MKSUPPORT) clean
	$(RM) -rf obj lib
	$(RM) -f *.bin *.dmap *.cgpr *.trace.* *.trace *~ \
                 *.xcov *.html *.css *.xml $(TESTS) *.alis *.routines

.PHONY: force clean
