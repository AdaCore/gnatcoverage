%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                      Couverture report LaTeX template                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,12pt,twoside]{article}
\usepackage{couverture}
\usepackage[T1]{fontenc}
%% \usepackage[french]{babel}
\usepackage[latin1]{inputenc}
\usepackage{url}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{theorem}{\textsc{Theroem}}

\begin{document}
\pagestyle{empty}

\vfill

\begin{center}%
{\Large \textbf{Couverture Project}}

{\Large \textbf{Technical Report on OBC/MCDC properties}}

\vfill

{\large \textbf{Abstract}}
\end{center}

This document gathers results established or formalized by the Couverture
project team about relationships between specific coverage criteria.
%
We focus in particular on how \E{Object Branch Coverage} (OBC) relates to the
\E{Modified Condition/Decision Coverage} (MCDC) criterion.

We provide two broad categories of results: formal proofs of important
properties over a model of the two criteria, and a machine-automated
verification of some of these properties for concrete subsets of the model
expressed in Alloy.
%
These results constitute the grounds on which our project coverage analysis
framework operates to infer source coverage results from object coverage
information out of an instrumented execution environment.

\vfill

\newpage
\pagestyle{plain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Common definitions}

\subsection{Decisions, conditions}

We are considering decisions that are short circuit boolean expressions,
i.e. expressions consisting in elementary boolean conditions combined
together using only the AND THEN, OR ELSE and NOT operators.

For each decision we construct the associated ROBDD (Reduced Ordered
Binary Decision Diagram), whose nodes are conditions. (RO)BDDs have an
entry point, and two or more exit edges labeled TRUE and FALSE.

\subsection{Binary decision diagrams}

In the remainder of this document, unless otherwise indicated, all
references to BDDs denote reduced ordered BDDs.

\subsection{Coverage metrics}

\subsubsection{Definitions}

% define MC/DC, OBC, BDDBC

This document deals with properties of tests exercising object code under
the assumption that the code generation chain accurately preserves the
decision process captured in the ROBDD. We specifically assume when
discussing object branch coverage of the object code, that we can instead
reason, unless indicated explicitly, on (RO)BDD branch coverage
of the corresponding BDD.

\subsection{Minimal test sets}

Coverage assessment is accomplished by exercising some piece of object
code in a variety of test cases, recording data along the way, and
then determining whether the successive executions of the object code
satisfy a given criterion of exhaustiveness. The minimum number of distinct
executions required to achieve a specific criterion is an important
aspect in the evaluation of any coverage assessment methodology. Here
we establish some properties that give a hard limit on test set size
for various coverage metries.

\subsubsection{OBC}

\subsubsection{MC/DC}

\begin{theorem}
MC/DC on a decision with $n$ independent conditions is achieved with
a test set of exactly $n+1$ tests, and cannot be achieved in fewer tests.
\end{theorem}

The existence of the test set is proved by induction. For one condition,
MC/DC is achieved with two tests, one setting it true and the other false.

Now assume that the property holds for all $n<N$, and consider a decision
with $N+1$ conditions. It is of the form $D = D_l \star D_r$ where
$\star$ is either AND THEN or OR ELSE. There is also possibly a negation,
which is omitted here since it has no impact on MC/DC. For the remainder
of this proof we assume the operator is AND THEN; the same reasoning applies
similarly for the case of OR ELSE.

$D_l$ and $D_r$ are decisions with respectively $n_l$ and $n_r$ conditions
(both at most $N$), and $n_l + n_r = N+1$. From the induction hypothesis
we have two test vector sets $T_l = \{ v_l (0) .. v_l (n_l) \}$ and
$T_r = \{ v_r (0) .. v_r (n_r) \}$ that satisfy MC/DC for $D_l$ and $D_r$
respectively, and we can arbitrarily choose the indices so that
$D_l$ is true for $v_l(0)$ and $D_r$ is true for $v_r (0)$.

We can now create a combined test set for the complete decision as follows.
$$(\forall j \in [0, n_l])\, v (j) = (v_l (j) \cdot v_r (0))$$
$$(\forall j \in [1, n_r])\, v (n_l + j) = (v_l (0) \cdot v_r (j))$$

We have thus created a set $T = { v(0) .. v(n_l + n_r) }$ of $N+2$ tests.
It is immediate that the elements with indices 0 to $n_l$ give for D
the same outcome as the corresponding elements of $T_l$ for $D_l$,
and they all have identical values for the conditions coming from $D_r$,
so they show independent influence of all conditions coming from $D_l$.
Similarly the vector set $\{v(0), v(n_l+1) .. v(n_l + n_r)\}$ shows
independent influence of those conditions coming from $D_r$, so the new
test set $T$ satisfies MC/DC for $D$ and thus the induction property holds at
$N+1$ as well, since $T$ has $n_l + n_r + 1 = N+2$ elements.

The proof that this is the minimal test set size is given in~\cite{ar0118}.

\subsection{Coverage assessment through analysis of execution traces}


\section{Characterization of cases of BDDBC --- MC/DC equivalence}

This section discusses the distinction between expressions for which
BDDBC of the associated ROBDD implies MC/DC, and expressions for which
no such implication holds.

\subsection{Construction of the ROBDD}

The BDD we associate with a decision is constructed using the following
recursive procedure:

\begin{description}
\item[Build\_BDD.Condition]
  The BDD for a decision consisting in a single condition C has the node
  "test C" as its entry point, the label TRUE is assigned to the branch
  corresponding to "C is TRUE", and the label FALSE is assigned to the
  branch corresponding to "C is FALSE".

\item[Build\_BDD.NOT]
  The BDD for "not (D)" is the BDD for D where the labels of the exit
  edges have been swapped.

\item[Build\_BDD.Short\_Circuit\_Operator]
  This rule defines how the BDD for "(D1) op (D2)" is constructed for
  any short-circuit operator "op".

  If OP is AND THEN, let SC be FALSE
  If OP is OR ELSE, let SC be TRUE

  Let B1 be the BDD for D1, and B2 the BDD for D2.

  Then B, the BDD for D is obtained by combining B1 and B2 as follows:
  \begin{itemize}
    \item the entry point is that of B1
    \item the exit edge labeled SC of B1 is an exit edge labeled SC of B
    \item the other exit edge of B1 connects to the entry point of B2
    \item the exit edges of B2 are exit edges of B with the same labels
  \end{itemize}
\end{description}

The following invariants of ROBDDs follow from the construction process:
\begin{itemize}
  \item There is exactly one BDD node for each condition.
  \item All condition nodes are reachable (i.e. there is a path from
        the entry point to any node in the BDD).
  \item There are no cycles in the BDD.
  \item Both outcomes are reachable (i.e. there is a path from the entry point
        to an exit edge labeled TRUE and to an exit edge labeled FALSE).
\end{itemize}

\subsection{Evaluation of a decision}

Given the transformation of a decision into its ROBDD, evaluating the
decision consists in computing its value using the following BDD traversal
procedure:

\begin{description}
\item[Eval.Condition]
  The value of a decision that consists in a lone condition is the
  value of the condition.

\item[Eval.Not]
  To evaluate "not (D)", evaluate D and take the opposite value

\item[Eval.Short\_Circuit\_Operator]
  To evaluate "(D1) op (D2)", evaluate D1. If D1 = SC then the
  value is SC, else evaluate D2, and the value is that of D2.
\end{description}

The following property holds:

\begin{description}
\item[Evals\_Are\_Paths]
  Evaluating a decision is equivalent to traversing the BDD, evaluating
  each condition as BDD nodes are traversed, and using the label of the
  exit edge as the value of the decision.
\end{description}

This property, and most other properties that we'll discuss here,
is proved by recurrence on the number of binary operators involved in
the expression. We'll assume that it holds for all $n <= N$, and then
consider an expression with $N+1$ binary operators, and prove that
the BDD construction step Build\_BDD.Short\_Circuit\_Operator preserves
the property from the two subdecision BDDs to the overall BDD.

Note that the practical implementation of coverage analysis systems based
on control flow traces relies on the assumption that the code generator
used to produce executable code from expressions actually implements this
evaluation strategy.

\subsection{Outcome reachability}

XXX well-known property of ROBDDs, could be included in list
of invariants trivially following the construction process???

\subsection{Equivalence case}

We now consider the case of an expression whose BDD has no diamond path,
i.e. for each BDD node there is exactly one path from the entry point to
that node. The following property holds:

\begin{description}
\item[BDDBC\_No\_Diamond\_Indep\_Implies\_MCDC]
  For a BDD with no diamond, if conditions are independent, then
  BDD branch coverage implies masking MC/DC coverage.
\end{description}

Let's consider a condition C. Since we have BDD branch coverage,
all possible paths starting at C have been taken (by recurrence on path
length, taking advantage of no cycles and no diamonds).

From the independenant outcome reachability property, we have two paths
starting at C, beginning each with one edge from C, and ending on the
two outcomes of the decision. Let's call them PCT and PCF.

These paths are disjoint: any condition appearing in one is masked
in the other (because of no-diamond).

These two paths are parts of paths PT and PF from the BDD entry point to
either outcome, and they cannot differ on the part of the path from the
entry point to C.

So, PT and PF differ in C, in no other condition before C, and in no
other non-masked condition after C, so they prove independant influence
of C over the decision.

This holds for each condition in the decision, so MC/DC is proved.

\subsection{Non-equivalence case}

Proved by constructing a set of paths that give BDD branch coverage but
not MC/DC coverage, taking advantage of the fact that we can reach the
same node C through two different paths.

\subsection{Conclusion}

We have proved the following property: for a decision D, BDDBC implies
MC/DC if, and only if, there are no diamonds in the associated ROBDD (i.e.
no node of the ROBDD is reachable through more that one path from the root).

\section{A second characterization of the equivalence case}

In this section we provide an alternative (equivalent) property
that characterizes cases where BDDBC implies MC/DC:
NNF-has-no-bar-in-LHS-of-foo.

\section{Examples}

This section discusses in detail some expressions that exemplify the properties
studied above.

\subsection{The elementary non-equivalence case}

$(A \land B) \lor C$

... insert BDD ...
... insert BDDBC test set (3 vectors, can't show MC/DC) ..

Intuitively, BDDBC is a local property of BDD traversals (i.e. of evaluations
of the decision): it is evaluated individually for each BDD node, without
respect to how the BDD node was reached. In contrast, MC/DC is a non-local
property, since it involves the complete path through the BDD. To establish
independant influence of condition C, it is necessary to study what happens
for two values of C leading to different outcomes, \emph{with all other
conditions fixed}, i.e. considering a single way of \emph{arriving to C}.

\subsection{Mixed operators cases}

For a decision involving a single operator kind and no negations, it is
immediate that OBC and MC/DC are equivalent. Now there are cases when
operators can be mixed without introducing non-equivalence, and cases
(involving negations) where there is no equivalence even though a single
kind of binary operator is used.

\subsection{A pathological example}

This section discusses a class of expressions that can have an arbitrary
high number $n$ of conditions (and require a minimum of $n+1$ tests to
establish MC/DC), and yet are fully covered with respect to BDDBC in
just three tests.

\section{General stateless MC/DC assessment}

This section discusses a code transformation after which stateless BDDBC
traces carry sufficient information to assess MC/DC coverage.

\section{Automated verifications}

\newpage
\bibliographystyle{alpha}
\bibliography{couverture}

\end{document}
