# This support Makefile is a helper for examples packaged together with the
# xcov/qemu bundle for coverage analysis.  The intent is to have this Makefile
# invoked from the example dedicated directories.

# It is useful both to factorize the work for different examples and to
# illustrate a typical coverage data generation sequence for a program
# starting from sources.

# The basic idea is
#  1/ Build the program executable from the sources
#  2/ Run it through qemu to get execution traces
#  3/ Use xcov to produce user level coverage data from the traces

# Set of main target programs for which we want to produce coverage info,
# to be defined from the command line or by includers:
# TESTS=
#
# ??? More than one entry in this list is not completely supported yet.
# Everything is done to have the correct sequence of operations for
# each, but final results for one are likely to be intermixed or partially
# clobbered by those for another.

.PRECIOUS: %.trace

include ../support/Makefile.common

all: build trace analyze

# -----------------------------------------------------------------------
# analyze: produce annotated sources or html from a trace file and
#          the corresponding executable
# -----------------------------------------------------------------------

analyze: $(TESTS:%=index-%.html) $(UNIT_TESTS:%=index-%.html)

index-%.html: %.trace
	# In e.g. the Aunit case, we're only interested in results for
	# our applicative objects so query for the specific list of relevant
	# symbols, which implicitly excludes (hence doesn't list) results
	# for the test-harness code.
	$(XCOV) --disp-routines $(wildcard obj/$(TARGET)/*.o) > $<.list
	$(XCOV) --routine-list=$<.list \
	 --coverage=branch --annotate=html+asm $<
	cp index.html $@

# -----------------------------------------------------------------------
# trace: produce execution trace from executable program execution
#        within instrumented target emulation environment
# -----------------------------------------------------------------------

trace: $(TESTS:%=%.trace) $(UNIT_TESTS:%=%.trace)

%.trace: % force
# echo the command we're planning to run while our term
# is functional, then run silently in between the possibly
# required stty adjustments. Switching to e.g raw would
# have the command output start right after the command echo
# on the same line, cumbersome.
	@echo xcov --run --target=$(TARGET) $<
	@$(STTY_ADJUST)
	-@xcov --run --target=$(TARGET) $<
	@$(STTY_RESTORE)

# -----------------------------------------------------------------------
# build: produce executable program from sources + target bsp
# -----------------------------------------------------------------------

build: $(TESTS) $(UNIT_TESTS)

$(TESTS): support force
	$(BUILDER) -p -P$@

$(UNIT_TESTS): support force
	$(BUILDER) -XPLATFORM=$(TARGETNAME) -XRUNTIME=zfp \
	 -XUNITTEST=yes -p -Pharness

support:
	$(MAKE) -C ../support

# Housekeeping

clean:
	$(MAKE) -C ../support clean
	$(RM) -rf obj lib
	$(RM) -f *.bin *.trace.list *.trace *~ *.xcov *.html *.css $(TESTS)

.PHONY: force clean
